<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script>
        // 아래 4가지  형식에 대해 호출시 다른점이 있습니다.
        // 여기 9번 라인 현재 위치는 함수 정의 보다 앞입니다.
        //기본은 아직 정의되어 있지 않은 함수는 호출할 수 없습니다.
        //단, function 함수이름(){}로 정의된 함수는 함수 끌어올리기(hoisting)를 하여 사용할 수 있습니다.
        let result = 0;
        result = myfuncA(3,1);
        console.log('@@@')
        //기본형식 1
        function myfuncA(x, y) {      //인자가 2개 입니다.
            let temp = x * 10 + y;
            console.log("myfuncA 실행하기!!")
            console.log("리턴값 = " + temp)
            return temp;      //샘플 수식
        }

        //기본형식 2 - 함수를 값처럼 변수 const 에 대입. 참조변수명이 함수이름이 됩니다.
        const myfuncB = function (x, y) {
            let temp = x * 10 + y;
            console.log("myfuncB 실행하기!!")
            console.log("리턴값 = " + temp)
            return temp;      //샘플 수식
        }

        //형식 3 - 화살표 함수(arrow function). 메소드의 인자가 함수 일 때 많이 사용합니다.
        const myfuncC = (x, y) => {
            let temp = x * 10 + y;
            console.log("myfuncC 실행하기!!")
            console.log("리턴값 = " + temp)
            return temp;      //샘플 수식
        }
    </script>
</head>

<body>
    <!-- 인자값 없거나 부족하면 연산 못함(NaN) -->
    <button onclick="myfuncA()">함수A 실행하기</button>
    <button onclick="myfuncA(2)">함수A 실행하기</button>
    <button onclick="myfuncA(2,4)">함수A 실행하기</button>
    <hr>
    <button onclick="myfuncB(2,6)">함수B 실행하기</button>
    <button onclick="myfuncC(2,5)">함수C 실행하기</button>

    <script>
        // 이 위치는 함수정의보다 뒤에 있습니다.
        //함수 호출에 아무문제가 없습니다.
         result = 0;
        result = myfuncA(3, 1);
        console.log('## myfuncA 리턴 =', result)
        result = myfuncB(3, "2")        //오류는 없지만 + 대신 문자열 연결연산합니다.
        console.log('## myfuncB 리턴 =', result)
        result = myfuncC(3, 3)
        console.log('## myfuncC 리턴 =', result)

    </script>
</body>

</html>